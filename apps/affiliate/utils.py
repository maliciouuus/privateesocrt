import string
import random
from django.utils import timezone
from django.conf import settings
from django.db.models import Sum
from decimal import Decimal
import logging

from apps.accounts.models import User
from .models import ReferralClick, Referral, Commission

logger = logging.getLogger(__name__)


class AffiliateService:
    """
    Service pour g√©rer les fonctionnalit√©s d'affiliation.
    Fournit des m√©thodes pour g√©n√©rer, valider et traiter les codes de r√©f√©rence.
    """

    @staticmethod
    def generate_referral_code(user=None, length=8):
        """
        G√©n√®re un code de r√©f√©rence unique pour un utilisateur.
        """
        # Caract√®res autoris√©s (lettres majuscules et chiffres, excluant les caract√®res ambigus)
        chars = "".join(c for c in string.ascii_uppercase + string.digits if c not in "OIL01")

        # Si un utilisateur est fourni, utiliser les deux premi√®res lettres de son nom d'utilisateur
        prefix = ""
        if user and user.username:
            prefix = "".join(c.upper() for c in user.username[:2] if c.isalpha())

        # Compl√©ter jusqu'√† la longueur demand√©e avec des caract√®res al√©atoires
        remaining_length = length - len(prefix)
        if remaining_length > 0:
            random_part = "".join(random.choices(chars, k=remaining_length))
            code = prefix + random_part
        else:
            code = "".join(random.choices(chars, k=length))

        # V√©rifier l'unicit√©
        while User.objects.filter(referral_code=code).exists():
            random_part = "".join(random.choices(chars, k=length - len(prefix)))
            code = prefix + random_part

        return code

    @staticmethod
    def process_referral(referred_user, referrer_code):
        """
        Traite un parrainage entre un utilisateur et un code de parrain.
        Retourne True si le parrainage a √©t√© trait√© avec succ√®s, False sinon.

        Args:
            referred_user (User): L'utilisateur parrain√©
            referrer_code (str): Le code de parrainage

        Returns:
            bool: True si le parrainage a √©t√© cr√©√©/mis √† jour avec succ√®s
        """
        # AM√âLIORATION: Validation approfondie des param√®tres
        if not referred_user or not referrer_code:
            if not referred_user:
                logger.error("‚ùå Erreur critique: Aucun utilisateur fourni pour le parrainage")
            if not referrer_code:
                logger.error("‚ùå Erreur critique: Aucun code de parrainage fourni")
            return False

        # AM√âLIORATION: Journalisation avec identifiants pour faciliter le d√©bogage
        user_id = getattr(referred_user, "id", "inconnu")
        username = getattr(referred_user, "username", "inconnu")
        logger.info(
            f"üîÑ Traitement de la relation d'affiliation pour {username} (ID: {user_id}) avec le code {referrer_code}"
        )

        # Chercher le parrain par son code avec gestion d'erreur am√©lior√©e
        try:
            referrer = User.objects.get(referral_code=referrer_code)
            logger.info(f"‚úÖ Parrain trouv√©: {referrer.username} (ID: {referrer.id})")

            # AM√âLIORATION: V√©rifications renforc√©es et gestion des cas d'erreur
            # V√©rifier que l'utilisateur n'est pas d√©j√† parrain√©
            if referred_user.referred_by:
                current_referrer = referred_user.referred_by
                logger.warning(
                    f"‚ö†Ô∏è L'utilisateur a d√©j√† un parrain: {current_referrer.username} (ID: {current_referrer.id})"
                )

                # V√©rifier si c'est le m√™me parrain (cas de r√©inscription)
                if current_referrer.id == referrer.id:
                    logger.info(f"‚úÖ M√™me parrain d√©tect√©, mise √† jour des relations existantes")
                else:
                    # AM√âLIORATION: Option pour forcer le nouveau parrain (d√©sactiv√©e par d√©faut)
                    force_update = getattr(settings, "AFFILIATE_FORCE_UPDATE_REFERRER", False)
                    if force_update:
                        logger.warning(
                            f"‚ö†Ô∏è Modification du parrain: {current_referrer.username} -> {referrer.username}"
                        )
                    else:
                        logger.warning(f"‚ùå Conservation du parrain existant (force_update=False)")
                        return False

            # V√©rifier qu'un utilisateur ne peut pas se parrainer lui-m√™me
            if referrer.id == referred_user.id:
                logger.error(
                    f"‚ùå Un utilisateur ne peut pas se parrainer lui-m√™me: {username} (ID: {user_id})"
                )
                return False

            # V√©rifier si referrer est un ambassadeur (validit√© du parrainage)
            if getattr(referrer, "user_type", None) not in ["ambassador", "admin"]:
                logger.warning(
                    f"‚ö†Ô∏è Le parrain {referrer.username} n'est pas un ambassadeur (type: {getattr(referrer, 'user_type', 'unknown')})"
                )
                # AM√âLIORATION: Option pour permettre ou non les parrains non-ambassadeurs
                allow_non_ambassador = getattr(
                    settings, "AFFILIATE_ALLOW_NON_AMBASSADOR_REFERRER", True
                )
                if not allow_non_ambassador:
                    logger.error(
                        f"‚ùå Parrainage rejet√©: seuls les ambassadeurs peuvent parrainer (allow_non_ambassador=False)"
                    )
                    return False

            # AM√âLIORATION: Transaction atomique pour garantir l'int√©grit√© des donn√©es
            from django.db import transaction

            with transaction.atomic():
                # Assigner le parrain √† l'utilisateur
                referred_user.referred_by = referrer
                referred_user.save(update_fields=["referred_by"])
                logger.info(
                    f"‚úÖ Parrain assign√© √† l'utilisateur: {username} -> {referrer.username}"
                )

                # Cr√©er une entr√©e de parrainage dans l'application affiliate
                referral, created = Referral.objects.get_or_create(
                    ambassador=referrer,
                    referred_user=referred_user,
                    defaults={
                        "is_active": True,
                        "created_at": timezone.now(),
                        "total_earnings": Decimal("0.00"),
                    },
                )

                if created:
                    logger.info(
                        f"‚úÖ Nouvelle entr√©e Referral cr√©√©e: {referrer.username} -> {username}"
                    )
                else:
                    logger.info(
                        f"‚ÑπÔ∏è Entr√©e Referral existante mise √† jour: {referrer.username} -> {username}"
                    )

            # AM√âLIORATION: Gestion des notifications dans un bloc s√©par√© pour √©viter l'√©chec complet
            # du parrainage si la notification √©choue

            try:
                send_referral_notification(referrer, referred_user)
            except Exception as e:
                logger.error(
                    f"‚ùå Erreur lors de l'envoi de la notification Telegram: {str(e)}",
                    exc_info=True,
                )

            # AM√âLIORATION: Cr√©ation des commissions adapt√©e au type d'utilisateur
            try:
                # Commission uniquement si c'est un nouvel ambassadeur (pas pour les utilisateurs standard)
                if referred_user.user_type == "ambassador" and created:
                    commission = AffiliateService.create_signup_commission(referral)
                    if commission:
                        logger.info(
                            f"üí∞ Commission d'inscription cr√©√©e: {commission.amount}‚Ç¨ pour {referrer.username}"
                        )
            except Exception as e:
                logger.error(
                    f"‚ùå Erreur lors de la cr√©ation de la commission: {str(e)}",
                    exc_info=True,
                )

            return True

        except User.DoesNotExist:
            logger.error(f"‚ùå Aucun utilisateur trouv√© avec le code de parrainage: {referrer_code}")
            return False
        except Exception as e:
            logger.error(
                f"‚ùå Exception non g√©r√©e lors du traitement du parrainage: {str(e)}",
                exc_info=True,
            )
            return False

    @staticmethod
    def create_signup_commission(referral, amount=None):
        """
        Cr√©e une commission pour l'inscription d'un nouvel ambassadeur.
        """
        if amount is None:
            # Utiliser un montant fixe pour les inscriptions d'ambassadeurs
            amount = Decimal("10.00")

        commission = Commission.objects.create(
            referral=referral,
            amount=amount,
            commission_type="signup",
            description=f"Commission pour l'inscription de {referral.referred_user.username}",
            status="approved",  # Auto-approuver les commissions d'inscription
        )

        # Mettre √† jour le total des gains du parrainage
        referral.total_earnings = referral.commissions.filter(
            status__in=["approved", "paid"]
        ).aggregate(Sum("amount"))["amount__sum"] or Decimal("0.00")
        referral.save(update_fields=["total_earnings"])

        return commission

    @staticmethod
    def track_click(ambassador, request):
        """
        Enregistre un clic sur le lien de parrainage d'un ambassadeur.
        """
        # Cr√©er ou r√©cup√©rer une entr√©e de clic
        click = ReferralClick.objects.create(
            user=ambassador,
            ip_address=request.META.get("REMOTE_ADDR", "0.0.0.0"),
            user_agent=request.META.get("HTTP_USER_AGENT", ""),
            referrer=request.META.get("HTTP_REFERER", ""),
            landing_page=request.build_absolute_uri(),
        )

        return click

    @staticmethod
    def get_ambassador_stats(ambassador):
        """
        R√©cup√®re les statistiques d'un ambassadeur.
        """
        # R√©cup√©rer tous les utilisateurs r√©f√©r√©s
        all_referred_users = User.objects.filter(referred_by=ambassador)

        # S√©parer les ambassadeurs des utilisateurs standard
        ambassador_referrals = all_referred_users.filter(user_type="ambassador").count()
        standard_referrals = all_referred_users.filter(user_type="standard").count()

        stats = {
            "clicks": ReferralClick.objects.filter(user=ambassador).count(),
            "referrals": Referral.objects.filter(referrer=ambassador).count(),
            "ambassador_referrals": ambassador_referrals,
            "standard_referrals": standard_referrals,
            "earnings": Commission.objects.filter(
                referral__referrer=ambassador, status__in=["approved", "paid"]
            ).aggregate(Sum("amount"))["amount__sum"]
            or Decimal("0.00"),
            "pending_earnings": Commission.objects.filter(
                referral__referrer=ambassador, status="pending"
            ).aggregate(Sum("amount"))["amount__sum"]
            or Decimal("0.00"),
        }

        # Calcul du taux de conversion
        if stats["clicks"] > 0:
            stats["conversion_rate"] = (stats["referrals"] / stats["clicks"]) * 100
        else:
            stats["conversion_rate"] = 0

        return stats


# AM√âLIORATION: Fonction auxiliaire pour l'envoi de notification avec retry
def send_referral_notification(referrer, referred_user):
    """
    Envoie une notification Telegram au parrain avec m√©canisme de retry
    """
    notification_sent = False
    max_retries = getattr(settings, "AFFILIATE_NOTIFICATION_MAX_RETRIES", 3)
    retry_count = 0

    while not notification_sent and retry_count < max_retries:
        try:
            from apps.dashboard.telegram_bot import TelegramNotifier

            notifier = TelegramNotifier()
            success = notifier.send_new_ambassador_notification(referrer, referred_user)

            if success:
                logger.info(
                    f"‚úÖ Notification Telegram envoy√©e √† {referrer.username} (tentative {retry_count+1}/{max_retries})"
                )
                notification_sent = True
            else:
                logger.warning(
                    f"‚ö†Ô∏è Tentative {retry_count+1}/{max_retries}: √âchec de l'envoi de la notification Telegram √† {referrer.username}"
                )
                retry_count += 1
                import time

                time.sleep(1)  # Attendre 1 seconde avant de r√©essayer
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de l'envoi de la notification Telegram: {str(e)}")
            retry_count += 1
            import time

            time.sleep(1)  # Attendre 1 seconde avant de r√©essayer

    return notification_sent
